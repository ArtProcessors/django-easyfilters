====================
 django-easyfilters
====================

ALPHA software! Starting to get useful, but APIs still not quite settled.

Overview
========

An app that provides filters like list_filter and date_hierarchy in Django's
admin, but for use outside the admin, with result counts for the choices,
and with more intelligence and things 'just working'.

The UI of the filters is links i.e. just click on links to add/remove
filters.  For fields where the values are more like a continuum, the aim is
to use autogenerated, intelligent ranges.  Dates will use something like the
Django admin's date_hierarchy feature.


Install
=======

Just install using pip/easy_install - this is a pure Python library that doesn't
need to be in INSTALLED_APPS.

Usage
=====

Suppose your model.py looks something like this::

    class Book(models.Model):
        name = models.CharField(max_length=100)
        binding = models.CharField(max_length=2, choices=BINDING_CHOICES)
        authors = models.ManyToManyField(Author)
        genre = models.ForeignKey(Genre)
        price = models.DecimalField(max_digits=6, decimal_places=2)
        date_published = models.DateField()

(BINDING_CHOICES, Author and Genre omitted for brevity).

And you have a views.py something like this::

    from myapp.models import Book

    def booklist(request):
        books = Book.objects.all()
        return render(request, "booklist.html", {'books': books})


and a template like this::

    {% for book in books %}
       {# etc #}
    {% endfor %}


To add the filters, in views.py you do something like this::

    from django_easyfilters import FilterSet
    from myapp.models import Book

    class BookFilterSet(FilterSet):
        model = Book
        fields = [
            'binding',
            'authors',
            'genre',
            'price',
            ]

    def booklist(request):
        books = Book.objects.all()
        booksfilter = BookFilterSet(books, request.GET)
        return render(request, "booklist.html", {'books': booksfilter.qs,
                                                 'booksfilter': booksfilter})

Then, in the template, just add ``{{ booksfilter }}`` above the list of
books. You can also use pagination e.g. using django-pagination::

    {% autopaginate books 20 %}

    <h1>Filters:</h1>
    {{ booksfilter }}

    {% paginate %}

    {% for book in books %}
       {# etc #}
    {% endfor %}

Customisation of the filters can be done using a tuple containing (field_name,
FilterOptions), instead of just field_name::

    class BookFilterSet(FilterSet):
        model = Book
        fields = [
            'binding',
            ('genre', FilterOptions(order_by_count=True))
        ]

Done so far
===========

* Support for ForeignKey - RelatedFilter
* Fallback support for CharField, IntegerField, everything else - ValuesFilter
* Options:

  * order_by_count

* Very good test coverage

TODO
====

* ManyToManyField
* DateField, DateTimeField
* Better support for Field.choices
* Automatic range-based filters - e.g. for prices
* More options for customisation

  * max_links
  * max_links_visible (javascript hiding)
  * 'defaults' attribute for FilterSet

* Docs for customisation

  * Options provided by FilterOptions
  * API of Filter
  * API of FilterSet for overriding rendering


Development
===========

First, ensure the directory containing this README is on your Python path
(virtualenv recommended). Django is a required dependency.

To run the test suite, do::

   ./manage.py test django_easyfilters

To edit the test fixtures, you can edit the fixtures in
django_easyfilters/tests/fixtures/, or you can do it via an admin interface:

First create an empty db::

   rm tests.db
   ./manage.py syncdb

Then load with current test fixture::

   ./manage.py loaddata django_easyfilters_tests

Then edit in admin at http://localhost:8000/admin/ ::

   ./manage.py runserver

Or from a Python shell.

Then dump data::

  ./manage.py dumpdata tests --format=json --indent=2 > django_easyfilters/tests/fixtures/django_easyfilters_tests.json
